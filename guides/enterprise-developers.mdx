---
title: "For Enterprise Developers"
description: "Programmatic integration patterns for building applications on the Scope3 Campaign API"
icon: "code"
---

Perfect for **developers, DevOps engineers, and technical teams** building applications that integrate with programmatic advertising.

## Who This Is For

- Backend developers building marketing platforms
- DevOps teams automating campaign management
- Data engineers integrating with BI systems
- Technical teams building custom dashboards

## Architecture Overview

The Scope3 Campaign API follows RESTful principles with GraphQL-powered data layer:

```
Your Application
├── Authentication Layer (API Keys)
├── Campaign Management (CRUD operations)
├── Real-time Integration (Webhooks)
├── Analytics Integration (Data Export)
└── Monitoring & Alerting (Health Checks)
```

## Quick Integration

### Authentication Setup

```javascript
// Environment configuration
const SCOPE3_API_KEY = process.env.SCOPE3_API_KEY;
const API_BASE_URL = 'https://api.agentic.scope3.com';

// HTTP client configuration
const headers = {
  'x-scope3-api-key': SCOPE3_API_KEY,
  'Content-Type': 'application/json',
  'User-Agent': 'MyApp/1.0'
};

// Test authentication
async function testAuth() {
  const response = await fetch(`${API_BASE_URL}/auth/check`, {
    method: 'GET',
    headers
  });
  return response.json();
}
```

### SDK Integration

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript
    import { Scope3Client } from '@scope3/campaign-api';
    
    const client = new Scope3Client({
      apiKey: process.env.SCOPE3_API_KEY,
      baseUrl: 'https://api.agentic.scope3.com'
    });
    
    // Create brand agent
    const brandAgent = await client.createBrandAgent({
      name: 'Nike',
      description: 'Athletic footwear and apparel'
    });
    
    // Create campaign
    const campaign = await client.createCampaign({
      brandAgentId: brandAgent.id,
      name: 'Nike Holiday Campaign 2024',
      budget: { total: 50000, currency: 'USD' },
      prompt: 'Target sports enthusiasts aged 25-45 for holiday shopping'
    });
    ```
  </Tab>
  <Tab title="Python Integration">
    ```python
    import requests
    import os
    
    class Scope3Client:
        def __init__(self):
            self.api_key = os.getenv('SCOPE3_API_KEY')
            self.base_url = 'https://api.agentic.scope3.com'
            self.headers = {
                'x-scope3-api-key': self.api_key,
                'Content-Type': 'application/json'
            }
        
        def create_brand_agent(self, name, description=None):
            payload = {'name': name}
            if description:
                payload['description'] = description
                
            response = requests.post(
                f'{self.base_url}/brand-agents',
                json=payload,
                headers=self.headers
            )
            return response.json()
        
        def get_campaign_summary(self, campaign_id):
            response = requests.get(
                f'{self.base_url}/campaigns/{campaign_id}/summary',
                headers=self.headers
            )
            return response.json()
    
    # Usage
    client = Scope3Client()
    brand_agent = client.create_brand_agent('Nike', 'Athletic brand')
    ```
  </Tab>
</Tabs>

## Core Integration Patterns

### 1. Resource Management Pattern

```javascript
class CampaignManager {
  constructor(apiKey) {
    this.client = new Scope3Client({ apiKey });
    this.cache = new Map(); // Resource caching
  }
  
  async setupBrandAgent(brandData) {
    // 1. Create brand agent
    const brandAgent = await this.client.createBrandAgent(brandData);
    
    // 2. Configure brand standards
    await this.client.setBrandStandards(brandAgent.id, {
      domainBlocklist: brandData.blockedDomains || [],
      keywordFilters: brandData.sensitiveKeywords || []
    });
    
    // 3. Add creative assets
    const creatives = [];
    for (const creative of brandData.creatives) {
      const created = await this.client.createCreative({
        brandAgentId: brandAgent.id,
        ...creative
      });
      creatives.push(created);
    }
    
    // 4. Cache for future use
    this.cache.set(brandAgent.id, { brandAgent, creatives });
    
    return { brandAgent, creatives };
  }
  
  async launchCampaign(campaignConfig) {
    const { brandAgentId } = campaignConfig;
    const cached = this.cache.get(brandAgentId);
    
    if (!cached) {
      throw new Error(`Brand agent ${brandAgentId} not found in cache`);
    }
    
    // Select appropriate creatives
    const creativeIds = this.selectCreatives(
      cached.creatives, 
      campaignConfig.creativeTypes
    );
    
    // Launch campaign
    const campaign = await this.client.createCampaign({
      ...campaignConfig,
      creativeIds
    });
    
    return campaign;
  }
}
```

### 2. Data Pipeline Integration

```javascript
// BI System Integration
class Scope3Analytics {
  constructor(apiKey, dataWarehouse) {
    this.client = new Scope3Client({ apiKey });
    this.warehouse = dataWarehouse; // BigQuery, Snowflake, etc.
  }
  
  async syncCampaignData(dateRange) {
    // 1. Get all brand agents
    const brandAgents = await this.client.listBrandAgents();
    
    // 2. Export data for each brand agent
    const exports = [];
    for (const brandAgent of brandAgents.data) {
      const exportData = await this.client.exportCampaignData({
        brandAgentId: brandAgent.id,
        dateRange,
        datasets: ['delivery', 'events', 'tactics'],
        groupBy: ['date', 'campaign', 'tactic', 'signal', 'story'],
        format: 'parquet',
        compression: 'gzip'
      });
      exports.push(exportData);
    }
    
    // 3. Load into data warehouse
    await this.loadToWarehouse(exports);
    
    // 4. Update dashboards/reports
    await this.refreshDashboards();
  }
  
  async loadToWarehouse(exports) {
    for (const exportData of exports) {
      if (exportData.downloadUrl) {
        // Large export - download and load
        await this.warehouse.loadFromUrl(exportData.downloadUrl);
      } else {
        // Small export - load directly
        await this.warehouse.loadData(exportData.data);
      }
    }
  }
}

// Scheduled execution
const analytics = new Scope3Analytics(
  process.env.SCOPE3_API_KEY,
  new BigQueryWarehouse()
);

// Run daily at 6 AM UTC
cron.schedule('0 6 * * *', async () => {
  const yesterday = {
    start: moment().subtract(1, 'day').format('YYYY-MM-DD'),
    end: moment().subtract(1, 'day').format('YYYY-MM-DD')
  };
  
  await analytics.syncCampaignData(yesterday);
});
```

### 3. Webhook Event Processing

```javascript
// Express.js webhook handler
const express = require('express');
const crypto = require('crypto');
const app = express();

// Webhook signature verification
function verifyWebhookSignature(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature, 'hex'),
    Buffer.from(expectedSignature, 'hex')
  );
}

// Webhook endpoint
app.post('/webhooks/scope3', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-scope3-signature'];
  const webhookSecret = process.env.SCOPE3_WEBHOOK_SECRET;
  
  // Verify signature
  if (!verifyWebhookSignature(req.body, signature, webhookSecret)) {
    return res.status(401).send('Invalid signature');
  }
  
  const event = JSON.parse(req.body.toString());
  
  // Process different event types
  switch (event.eventType) {
    case 'threshold_alert':
      handleBudgetAlert(event);
      break;
      
    case 'performance_event':
      handlePerformanceAlert(event);
      break;
      
    case 'delivery_update':
      handleDeliveryUpdate(event);
      break;
      
    default:
      console.log(`Unknown event type: ${event.eventType}`);
  }
  
  res.status(200).send('OK');
});

async function handleBudgetAlert(event) {
  const { campaignId, alertType, severity, details } = event;
  
  if (severity === 'critical') {
    // Send to PagerDuty/Slack
    await notificationService.sendAlert({
      type: 'campaign_budget_critical',
      campaignId,
      message: details.message,
      channels: ['slack', 'pagerduty']
    });
    
    // Auto-pause if spend is too high
    if (alertType === 'overspend' && details.overspendPercent > 50) {
      await scope3Client.updateCampaign(campaignId, { 
        status: 'paused' 
      });
    }
  }
}

async function handlePerformanceAlert(event) {
  const { campaignId, metrics, recommendations } = event;
  
  // Update performance tracking
  await performanceTracker.recordMetrics(campaignId, metrics);
  
  // Auto-optimize if confidence is high
  if (recommendations.length > 0 && recommendations[0].confidence > 0.8) {
    const rec = recommendations[0];
    
    if (rec.action === 'increase_budget') {
      await scope3Client.updateCampaign(campaignId, {
        budget: { total: rec.suggestedBudget }
      });
    }
  }
}
```

## Advanced Integration Patterns

### Batch Operations

```javascript
// Bulk campaign management
class BulkCampaignManager {
  constructor(client) {
    this.client = client;
    this.concurrencyLimit = 10;
  }
  
  async createMultipleCampaigns(campaignConfigs) {
    // Process in batches to respect rate limits
    const batches = this.chunk(campaignConfigs, this.concurrencyLimit);
    const results = [];
    
    for (const batch of batches) {
      const batchPromises = batch.map(config => 
        this.client.createCampaign(config)
          .catch(error => ({ error, config }))
      );
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
      
      // Rate limiting - wait between batches
      await this.delay(1000);
    }
    
    return results;
  }
  
  async bulkUpdateCampaigns(updates) {
    const results = [];
    
    for (const { campaignId, updates: campaignUpdates } of updates) {
      try {
        const result = await this.client.updateCampaign(
          campaignId, 
          campaignUpdates
        );
        results.push({ campaignId, success: true, data: result });
      } catch (error) {
        results.push({ campaignId, success: false, error });
      }
    }
    
    return results;
  }
  
  chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Error Handling & Retry Logic

```javascript
// Resilient API client
class ResilientScope3Client {
  constructor(apiKey) {
    this.client = new Scope3Client({ apiKey });
    this.maxRetries = 3;
    this.baseDelay = 1000; // 1 second
  }
  
  async makeRequest(operation, ...args) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await this.client[operation](...args);
      } catch (error) {
        lastError = error;
        
        // Don't retry client errors (4xx)
        if (error.status >= 400 && error.status < 500) {
          throw error;
        }
        
        // Exponential backoff for server errors (5xx) and network issues
        if (attempt < this.maxRetries) {
          const delay = this.baseDelay * Math.pow(2, attempt - 1);
          await this.delay(delay + Math.random() * 1000); // Add jitter
        }
      }
    }
    
    throw lastError;
  }
  
  // Wrapper methods
  async createCampaign(config) {
    return this.makeRequest('createCampaign', config);
  }
  
  async getCampaignSummary(campaignId, options) {
    return this.makeRequest('getCampaignSummary', campaignId, options);
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Performance Optimization

```javascript
// Caching and performance optimization
class OptimizedScope3Client {
  constructor(apiKey) {
    this.client = new Scope3Client({ apiKey });
    this.cache = new NodeCache({ stdTTL: 300 }); // 5-minute cache
    this.requestQueue = [];
    this.processing = false;
  }
  
  async getCampaignSummary(campaignId, options = {}) {
    const cacheKey = `summary_${campaignId}_${JSON.stringify(options)}`;
    
    // Check cache first
    let cached = this.cache.get(cacheKey);
    if (cached && !options.forceFresh) {
      return cached;
    }
    
    // Make request
    const result = await this.client.getCampaignSummary(campaignId, options);
    
    // Cache result
    this.cache.set(cacheKey, result);
    
    return result;
  }
  
  // Batch similar requests
  async batchGetSummaries(campaignIds) {
    const promises = campaignIds.map(id => 
      this.getCampaignSummary(id).catch(error => ({ error, campaignId: id }))
    );
    
    return Promise.all(promises);
  }
  
  // Prefetch commonly needed data
  async prefetchBrandAgentData(brandAgentId) {
    const [campaigns, creatives, audiences] = await Promise.all([
      this.client.listCampaigns({ brandAgentId }),
      this.client.listCreatives({ brandAgentId }),
      this.client.listAudiences({ brandAgentId })
    ]);
    
    // Cache all data
    this.cache.set(`campaigns_${brandAgentId}`, campaigns);
    this.cache.set(`creatives_${brandAgentId}`, creatives);
    this.cache.set(`audiences_${brandAgentId}`, audiences);
    
    return { campaigns, creatives, audiences };
  }
}
```

## Database Schema Examples

### Campaign Tracking Schema

<Tabs>
  <Tab title="PostgreSQL">
    ```sql
    -- Campaign tracking tables
    CREATE TABLE brand_agents (
      id VARCHAR(50) PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      description TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE TABLE campaigns (
      id VARCHAR(50) PRIMARY KEY,
      brand_agent_id VARCHAR(50) REFERENCES brand_agents(id),
      name VARCHAR(255) NOT NULL,
      status VARCHAR(50),
      budget_total DECIMAL(10,2),
      budget_currency VARCHAR(3),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE TABLE campaign_delivery (
      id SERIAL PRIMARY KEY,
      campaign_id VARCHAR(50) REFERENCES campaigns(id),
      date DATE NOT NULL,
      spend DECIMAL(10,2),
      impressions BIGINT,
      average_cpm DECIMAL(6,2),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(campaign_id, date)
    );
    
    CREATE TABLE campaign_events (
      id SERIAL PRIMARY KEY,
      campaign_id VARCHAR(50) REFERENCES campaigns(id),
      event_type VARCHAR(50) NOT NULL,
      tactic_id VARCHAR(50),
      signals TEXT[], -- Array of signals
      stories TEXT[], -- Array of stories
      reward_immediate DECIMAL(3,2),
      reward_delayed DECIMAL(3,2),
      reward_confidence DECIMAL(3,2),
      timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Indexes for performance
    CREATE INDEX idx_campaign_delivery_date ON campaign_delivery(date);
    CREATE INDEX idx_campaign_events_type ON campaign_events(event_type);
    CREATE INDEX idx_campaign_events_timestamp ON campaign_events(timestamp);
    ```
  </Tab>
  <Tab title="BigQuery">
    ```sql
    -- BigQuery schema for analytics
    CREATE TABLE `project.dataset.campaign_performance` (
      campaign_id STRING,
      brand_agent_id STRING,
      date DATE,
      tactic_id STRING,
      signals ARRAY<STRING>,
      stories ARRAY<STRING>,
      spend FLOAT64,
      impressions INT64,
      clicks INT64,
      conversions INT64,
      average_cpm FLOAT64,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
    )
    PARTITION BY date
    CLUSTER BY campaign_id;
    
    CREATE TABLE `project.dataset.campaign_events` (
      event_id STRING,
      campaign_id STRING,
      event_type STRING,
      tactic_id STRING,
      signals ARRAY<STRING>,
      stories ARRAY<STRING>,
      reward STRUCT<
        immediate FLOAT64,
        delayed FLOAT64,
        confidence FLOAT64
      >,
      timestamp TIMESTAMP,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
    )
    PARTITION BY DATE(timestamp)
    CLUSTER BY campaign_id;
    ```
  </Tab>
</Tabs>

## Monitoring & Observability

### Health Checks

```javascript
// Comprehensive health monitoring
class Scope3HealthMonitor {
  constructor(client) {
    this.client = client;
    this.metrics = {
      apiCalls: 0,
      errors: 0,
      latency: []
    };
  }
  
  async healthCheck() {
    const checks = {
      auth: await this.checkAuth(),
      apiLatency: await this.checkLatency(),
      webhookEndpoint: await this.checkWebhookEndpoint(),
      dataExports: await this.checkDataExports()
    };
    
    const healthy = Object.values(checks).every(check => check.status === 'ok');
    
    return {
      status: healthy ? 'healthy' : 'degraded',
      timestamp: new Date().toISOString(),
      checks,
      metrics: this.getMetrics()
    };
  }
  
  async checkAuth() {
    try {
      const start = Date.now();
      await this.client.checkAuth();
      const latency = Date.now() - start;
      
      return { 
        status: 'ok', 
        latency,
        message: 'Authentication successful'
      };
    } catch (error) {
      return { 
        status: 'error', 
        message: error.message 
      };
    }
  }
  
  async checkLatency() {
    const measurements = [];
    
    // Make 5 quick API calls to measure latency
    for (let i = 0; i < 5; i++) {
      const start = Date.now();
      try {
        await this.client.listBrandAgents({ limit: 1 });
        measurements.push(Date.now() - start);
      } catch (error) {
        measurements.push(null);
      }
    }
    
    const validMeasurements = measurements.filter(m => m !== null);
    const avgLatency = validMeasurements.reduce((a, b) => a + b, 0) / validMeasurements.length;
    
    return {
      status: avgLatency < 2000 ? 'ok' : 'warning',
      averageLatency: avgLatency,
      measurements: validMeasurements
    };
  }
  
  getMetrics() {
    return {
      totalApiCalls: this.metrics.apiCalls,
      totalErrors: this.metrics.errors,
      errorRate: this.metrics.errors / this.metrics.apiCalls,
      averageLatency: this.metrics.latency.reduce((a, b) => a + b, 0) / this.metrics.latency.length
    };
  }
}

// Integration with monitoring systems
class MetricsCollector {
  constructor(statsd) {
    this.statsd = statsd; // StatsD client
  }
  
  recordApiCall(operation, duration, success) {
    this.statsd.increment('scope3.api.calls', {
      operation,
      success: success.toString()
    });
    
    this.statsd.histogram('scope3.api.duration', duration, {
      operation
    });
    
    if (!success) {
      this.statsd.increment('scope3.api.errors', {
        operation
      });
    }
  }
  
  recordWebhookEvent(eventType, processingTime) {
    this.statsd.increment('scope3.webhook.events', {
      event_type: eventType
    });
    
    this.statsd.histogram('scope3.webhook.processing_time', processingTime, {
      event_type: eventType
    });
  }
}
```

## Testing Strategies

### Unit Testing

```javascript
// Jest/Mocha unit tests
describe('Scope3Client', () => {
  let client;
  let mockApiKey = 'test_api_key_123';
  
  beforeEach(() => {
    client = new Scope3Client({ apiKey: mockApiKey });
  });
  
  describe('createBrandAgent', () => {
    it('should create a brand agent successfully', async () => {
      const mockResponse = {
        id: 'ba_test123',
        name: 'Test Brand',
        status: 'active'
      };
      
      // Mock the HTTP request
      jest.spyOn(client, 'makeRequest').mockResolvedValue(mockResponse);
      
      const result = await client.createBrandAgent({
        name: 'Test Brand',
        description: 'Test description'
      });
      
      expect(result).toEqual(mockResponse);
      expect(client.makeRequest).toHaveBeenCalledWith(
        'POST',
        '/brand-agents',
        {
          name: 'Test Brand',
          description: 'Test description'
        }
      );
    });
    
    it('should handle API errors gracefully', async () => {
      jest.spyOn(client, 'makeRequest').mockRejectedValue(
        new Error('API Error: Invalid brand agent name')
      );
      
      await expect(client.createBrandAgent({ name: '' }))
        .rejects.toThrow('API Error: Invalid brand agent name');
    });
  });
  
  describe('getCampaignSummary', () => {
    it('should return campaign summary with health score', async () => {
      const mockSummary = {
        campaignId: 'camp_test123',
        healthScore: 87,
        spend: 12450.00,
        impressions: 2100000
      };
      
      jest.spyOn(client, 'makeRequest').mockResolvedValue(mockSummary);
      
      const result = await client.getCampaignSummary('camp_test123');
      
      expect(result).toEqual(mockSummary);
      expect(result.healthScore).toBeGreaterThan(0);
    });
  });
});
```

### Integration Testing

```javascript
// Integration tests with test environment
describe('Scope3 Integration Tests', () => {
  let client;
  let testBrandAgent;
  let testCampaign;
  
  beforeAll(async () => {
    client = new Scope3Client({
      apiKey: process.env.SCOPE3_TEST_API_KEY,
      baseUrl: 'https://api-test.agentic.scope3.com'
    });
    
    // Create test brand agent
    testBrandAgent = await client.createBrandAgent({
      name: `Test Brand ${Date.now()}`,
      description: 'Integration test brand agent'
    });
  });
  
  afterAll(async () => {
    // Clean up test data
    if (testBrandAgent) {
      await client.deleteBrandAgent(testBrandAgent.id);
    }
  });
  
  it('should complete full campaign lifecycle', async () => {
    // 1. Create creative
    const creative = await client.createCreative({
      brandAgentId: testBrandAgent.id,
      name: 'Test Creative',
      type: 'video',
      url: 'https://example.com/test-video.mp4'
    });
    
    expect(creative.id).toBeDefined();
    
    // 2. Create campaign
    testCampaign = await client.createCampaign({
      brandAgentId: testBrandAgent.id,
      name: 'Integration Test Campaign',
      budget: { total: 1000, currency: 'USD' },
      creativeIds: [creative.id],
      prompt: 'Test campaign for integration testing'
    });
    
    expect(testCampaign.id).toBeDefined();
    expect(testCampaign.status).toBe('scheduled');
    
    // 3. Get campaign summary
    const summary = await client.getCampaignSummary(testCampaign.id);
    expect(summary.campaignId).toBe(testCampaign.id);
    expect(summary.healthScore).toBeDefined();
    
    // 4. Update campaign
    const updated = await client.updateCampaign(testCampaign.id, {
      budget: { total: 1500, currency: 'USD' }
    });
    
    expect(updated.budget.total).toBe(1500);
  }, 30000); // 30 second timeout for integration tests
});
```

## Deployment Patterns

### Docker Configuration

```dockerfile
# Dockerfile for Scope3 integration service
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY src/ ./src/

# Health check endpoint
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node ./src/health-check.js

# Environment variables
ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

# Run as non-root user
USER node

CMD ["node", "src/server.js"]
```

### Kubernetes Deployment

```yaml
# kubernetes-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: scope3-integration
  labels:
    app: scope3-integration
spec:
  replicas: 3
  selector:
    matchLabels:
      app: scope3-integration
  template:
    metadata:
      labels:
        app: scope3-integration
    spec:
      containers:
      - name: scope3-integration
        image: your-registry/scope3-integration:latest
        ports:
        - containerPort: 3000
        env:
        - name: SCOPE3_API_KEY
          valueFrom:
            secretKeyRef:
              name: scope3-secrets
              key: api-key
        - name: WEBHOOK_SECRET
          valueFrom:
            secretKeyRef:
              name: scope3-secrets
              key: webhook-secret
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: scope3-integration-service
spec:
  selector:
    app: scope3-integration
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP
```

## Security Best Practices

### API Key Management

```javascript
// Secure API key handling
class SecureScope3Client {
  constructor(options = {}) {
    // Never log API keys
    this.apiKey = this.getApiKey(options);
    this.baseUrl = options.baseUrl || 'https://api.agentic.scope3.com';
    
    // Validate API key format
    if (!this.apiKey || !this.apiKey.startsWith('sk_')) {
      throw new Error('Invalid API key format');
    }
  }
  
  getApiKey(options) {
    // Priority order: parameter > environment > error
    return options.apiKey || 
           process.env.SCOPE3_API_KEY || 
           this.throwMissingApiKeyError();
  }
  
  throwMissingApiKeyError() {
    throw new Error(
      'Scope3 API key is required. Set SCOPE3_API_KEY environment variable or pass apiKey option.'
    );
  }
  
  // Mask API key in logs
  toString() {
    return `Scope3Client(apiKey=sk_***${this.apiKey.slice(-4)})`;
  }
}

// Environment-specific configuration
const getConfig = () => {
  const env = process.env.NODE_ENV || 'development';
  
  const configs = {
    development: {
      baseUrl: 'https://api-dev.agentic.scope3.com',
      logLevel: 'debug',
      rateLimitRetries: 3
    },
    staging: {
      baseUrl: 'https://api-staging.agentic.scope3.com',
      logLevel: 'info',
      rateLimitRetries: 5
    },
    production: {
      baseUrl: 'https://api.agentic.scope3.com',
      logLevel: 'warn',
      rateLimitRetries: 5
    }
  };
  
  return configs[env] || configs.development;
};
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Power Users Guide" href="/guides/power-users" icon="sparkles">
    Advanced analytics and machine learning features
  </Card>
  <Card title="API Reference" href="/api-reference/brand-agents/create-brand-agent" icon="book">
    Complete documentation for all endpoints
  </Card>
  <Card title="Webhook Setup" href="/webhooks/setup" icon="webhook">
    Real-time event processing and integration
  </Card>
  <Card title="Workflow Examples" href="/guides/workflow-examples" icon="play">
    End-to-end integration examples
  </Card>
</CardGroup>